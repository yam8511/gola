package werewolf

import (
	"encoding/json"
	"strconv"
)

// NewSeer å»ºç«‹æ–°Seer
func NewSeer(éŠæˆ² *Game, ä½å­ int) *Seer {
	human := NewHuman(éŠæˆ², ä½å­)
	return &Seer{
		Human: human,
	}
}

// Seer ç©å®¶
type Seer struct {
	*Human
}

func (æˆ‘ *Seer) ç¨®æ—() GROUP {
	return ç¥è·
}

func (æˆ‘ *Seer) è·æ¥­() RULE {
	return é è¨€å®¶
}

func (æˆ‘ *Seer) éœ€è¦å¤œæ™šè¡Œå‹•() bool {
	return true
}

func (æˆ‘ *Seer) èƒ½åŠ›(i int) (_ Player) {

	æˆ‘.éŠæˆ².æ—ç™½(å‚³è¼¸è³‡æ–™{Sound: "è«‹å•ä½ è¦æŸ¥é©—çš„å°è±¡æ˜¯ï¼Ÿ"}, 1500)

	if æˆ‘.å‡ºå±€äº†() || !æˆ‘.å·²ç¶“è¢«é¸æ“‡() {
		æˆ‘.éŠæˆ².ç­‰ä¸€ä¸‹(random(3) * 2500)
		return
	}

	å¯æŸ¥çœ‹çš„ç©å®¶è™Ÿç¢¼ := []int{}

	ç›®å‰å­˜æ´»ç©å®¶å€‘ := æˆ‘.éŠæˆ².å­˜æ´»ç©å®¶å€‘()
	for i := range ç›®å‰å­˜æ´»ç©å®¶å€‘ {
		ç©å®¶ := ç›®å‰å­˜æ´»ç©å®¶å€‘[i]
		if æˆ‘.è™Ÿç¢¼() == ç©å®¶.è™Ÿç¢¼() {
			continue
		}
		å¯æŸ¥çœ‹çš„ç©å®¶è™Ÿç¢¼ = append(å¯æŸ¥çœ‹çš„ç©å®¶è™Ÿç¢¼, ç©å®¶.è™Ÿç¢¼())
	}

	uid := newUID()
	æˆ‘.éŠæˆ².æ—ç™½æœ‰è©±å°å–®å€‹ç©å®¶èªª(æˆ‘, å‚³è¼¸è³‡æ–™{
		UID:     uid,
		Display: "è«‹å•ä½ è¦æŸ¥é©—çš„å°è±¡æ˜¯ï¼Ÿ",
		Action:  é¸æ“‡ç©å®¶,
		Data:    å¯æŸ¥çœ‹çš„ç©å®¶è™Ÿç¢¼,
	}, 0)

	for {

		so, err := æˆ‘.ç­‰å¾…å‹•ä½œ(é¸æ“‡ç©å®¶, uid)
		if err != nil {
			return
		}

		ç©å®¶è™Ÿç¢¼ := 0
		err = json.Unmarshal([]byte(so.Reply), &ç©å®¶è™Ÿç¢¼)
		if err != nil {
			continue
		}

		ç©å®¶, å­˜åœ¨ := æˆ‘.éŠæˆ².ç©å®¶è³‡æ–™(ç©å®¶è™Ÿç¢¼)
		if å­˜åœ¨ {
			var s = "æ˜¯ã€ğŸ˜å¥½äººã€ğŸ‘"

			if ç©å®¶.ç¨®æ—() == ç‹¼è· && ç©å®¶.è·æ¥­() != é›ªç‹¼ {
				s = "æ˜¯ã€ğŸºç‹¼äººã€ğŸ˜±"
			}

			uid := newUID()
			æˆ‘.éŠæˆ².æ—ç™½æœ‰è©±å°å–®å€‹ç©å®¶èªª(æˆ‘, å‚³è¼¸è³‡æ–™{
				UID:     uid,
				Display: strconv.Itoa(ç©å®¶è™Ÿç¢¼) + s,
				Action:  ç­‰å¾…å›æ‡‰,
			}, 0)

			æˆ‘.ç­‰å¾…å‹•ä½œ(ç­‰å¾…å›æ‡‰, uid)
			return
		}
	}
}
